## Условие

Рассмотрим простой язык программирования. Программа на этом языке представляет собой последовательность функций. Каждая функция имеет фиксированное количество целочисленных формальных параметров и возвращает целое число. Телом функции является единственное выражение, позволяющее выполнять над параметрами и целыми числами арифметические операции, операции сравнения и тернарную операцию выбора, а также вызывать функции.

Например, функция вычисления факториала числа на нашем языке может быть записана как
```
fact(x) := x=0 ? 1 : x*fact(x-1);
```
Более сложный пример демонстрирует функцию fib, вычисляющую n-ное число Фибоначчи:
```
fib(n) := fibrec(1,1,n);
fibrec(a,b,n) := n=1 ? a : fibrec(b,a+b,n-1);
```

Приведём формальное описание нашего языка.

Пусть программа состоит из лексем, разделённых произвольным (возможно, нулевым) количеством пробелов или символов перевода строки. При этом лексема – это либо идентификатор (имя формального параметра или имя функции), либо числовая константа, либо специальный символ.

Идентификатор – это непустая последовательность латинских букв и десятичных цифр, начинающаяся с буквы. В БНФ грамматики нашего языка идентификаторы будут обозначаться нетерминалом ``<ident>``.

Числовая константа – это непустая последовательность десятичных цифр. В БНФ мы будем использовать нетерминал ``<number>`` для обозначения числовой константы. Латинская буква не может располагаться в тексте программы непосредственно после числовой константы.

Специальные символы нашего языка включают знаки арифметических операций («+», «-», «*», «/»), знаки оперций сравнения («=», «<>», «<», «>», «<=», «>=»), знаки тернарной операции («?» и «:»), а также круглые скобки, запятую, точку с запятой и знак «:=», отделяющий заголовок функции от её тела.

Согласно грамматике нашего языка, программа – это последовательность функций:
```bnf
<program> ::= <function> <program>.
```
Объявление функции начинается с имени функции, за которым в круглых скобках следует список формальных параметров, знак «:=» и выражение, кодирующее тело функции. Заканчивается объявление функции точкой с запятой.
```bnf
<function> ::= <ident> ( <formal-args-list> ) := <expr> ; .
```
Список формальных параметров представляет собой список имен параметров, разделённых запятыми:
```bnf
<formal-args-list> ::= <ident-list> | .
<ident-list> ::= <ident> | <ident> , <ident-list>.
```
Выражение – это либо выражение выбора, использующее тернарную операцию в духе языка C, либо выражение сравнения:
```bnf
<expr> ::= 
    <comparison_expr> ? <comparison_expr> : <expr> 
    | <comparison_expr>.
```
Выражение сравнения представляет собой либо сравнение двух арифметичеких выражений, либо просто одно арифметическое выражение:
```bnf
<comparison_expr> ::= 
    <arith_expr> <comparison_op> <arith_expr> 
    | <arith_expr>.
<comparison_op> ::= = | <> | < | > | <= | >= .
```
Арифметическое выражение определяется следующими правилами грамматики:
```bnf
<arith_expr> ::= 
    <arith_expr> + <term> 
    | <arith_expr> - <term> 
    | <term>.
<term> ::= 
    <term> * <factor> 
    | <term> / <factor> 
    | <factor>.
<factor> ::= 
    <number> 
    | <ident> 
    | <ident> ( <actual_args_list> )
    | ( <expr> ) 
    | - <factor>.
```
Список фактических параметров определяется как список выражений, разделённых запятыми:
```bnf
<actual_args_list> ::= <expr-list> | .
<expr-list> ::= <expr> | <expr> , <expr-list>.
```
Предположим, что готовится к выходу вторая версия нашего языка, в которую добавили модульность. Теперь мы можем оформить некоторый набор функций в виде отдельного файла, откомпилировать этот файл и затем просто подключать его к другим программам и модулям. Особенностью реализации модульности в нашем языке будет невозможность циклического подключения модулей: например, нельзя подключить модуль A к модулю B, модуль B – к модулю C, а модуль C – к модулю A. Это означает, в частности, что если несколько функций – взаимно рекурсивны, то они обязательно должны быть объявлены в одном общем для них модуле.

Составьте программу, выполняющую оценку максимального числа модулей, на которые может быть разбита некоторая программа, написанная на нашем языке. В случае, если языком реализации программы выбран язык Java, то точкой входа в программу должен являться метод main класса Modules.

Программа должна считывать оцениваемую программу со стандартного потока ввода и выводить в стандартный поток вывода максимальное количество модулей или слово «error», если программа содержит ошибки.

Обратите внимание на то, что перед разработкой синтаксического анализатора необходимо удалить из приведённой выше грамматики левую рекурсию и факторизовать часть правил, чтобы получилась LL(1)-грамматика.